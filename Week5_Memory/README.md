# 🚀 5주차 - 메모리

## [👨‍🏫 강의](https://www.boostcourse.org/cs112/joinLectures/41489)
### 1️⃣ 메모리 주소
#### 강의 요약
* 16진수
  * 컴퓨터과학에서는 10진수나 2진수 대신 16진수(Hexadecimal)로 표현하는 경우가 많다.
  * 16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있다.
  * 2^4이 16이기 때문에 4bits씩 2진수의 0000부터 1111까지 16진수로 표현할 수 있다.
  * 10은 a, 11은 b, …, 15는 f를 대입하여 사용한다.
  * 4bits씩 16진수로 변환 후 0x를 붙여 뒤에 오는 문자들이 16진수임을 알려준다.
* 16진수의 유용성
  * 16진수로 표현하면 2진수로 표현했을 때보다 훨씬 간단해진다.
  * 2개의 16진수는 1byte의 2진수로 변환되기 때문에 정보를 표현하기에 매우 유용하다.
    * 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현한다.
* 메모리 주소
  * C에서는 변수의 메모리상 주소를 받기 위해 '&' 연산자를 사용할 수 있다.
    ``` C
    #include <stdio.h>

    int main(void)
    {
        int n = 50;
        printf("%p\n", &n);
    }
    ```
    * 위 코드를 실행하면 메모리상 주소값을 얻을 수 있고, 이는 변수 n의 16진법으로 표현된 메모리의 주소이다.
  * '\*' 연산자를 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있다.
    ``` C
    #include <stdio.h>

    int main(void)
    {
        int n = 50;
        printf("%i\n", *&n);
    }
    ```
    * 위 코드는 먼저 n의 주소를 얻고, 또 다시 그 주소에 해당하는 값을 얻어와 출력한 것이므로 결국 '50'이라는 값이 출력된다.
#### 생각해보기
* 💁‍♂ : 'CS50'을 16진수로 표현해볼까요?
  * 🙋‍♀️ : 0x43 0x53 0x26 0x21 -> 0x43533530  
    > 아스키코드 숫자표를 잘못 봄 & 컴퓨터는 바이트 단위로 정보를 표현하기 때문에 맨 처음에만 0x 표시를 해도 된다는 것을 인지하지 못 함.
#### 배운점
> 16진수가 짧게 표현된다는 점에서 유용하고 4개의 2진수가 곧 2개의 16진수 인 것은 알았지만,  
> 컴퓨터가 바이트 단위로 정보를 표현하기 때문에 그 점이 더욱 유용하게 쓰인다는 것은 인지하지 못 했다.  
> 이번 강의를 통해 확실하게 16진수가 유용한 이유를 알게되었다.  
> 또한 생각해보기에서 컴퓨터는 바이트 단위를 정보를 표현하니 맨 처음에만 0x 표시를 하면되는데, 그 점을 인지하지 못 했었다.  
> 생각해보기를 통해서 또 하나배웠다!

### 2️⃣ 포인터
#### 강의 요약
* '\*' 연산자를 이용해 포인터 역할을 하는 변수를 선언할 수 있다.
  ``` C
  #include <stdio.h>

  int main(void)
  {
     int n = 50;
     int *p = &n;
     printf("%p\n", p);
     printf("%i\n", *p);
  }
  ```
  * 위 코드를 보면 정수형 변수 n에 50이라는 값이 저장되어 있다.
  * \*p라는 포인터 변수에 &n 이라는 값, 즉 변수 n의 주소를 저장한다.
  * int \*p에서 p앞의 \*는 해당 변수가 포인터라는 의미고, int는 이 포인터가 int타입의 변수를 가리킨다는 의미이다.
    * 첫번째 printf문과 같이 포인터 p의 값, 즉 변수 n의 주소를 출력할 수 있다.
    * 두번째 printf문과 같이 포인터 p가 가리키는 변수의 값, 즉 n의 값을 출력할 수 있다.
  * 실제 컴퓨터 메모리에서는 p는 가르키는 주소값, 즉 변수 n의 주소값이 저장되어 있고, n은 50이라는 값이 저장되어 있다.
    * 하지만 실제로 p의 값, 즉 n의 주소값을 생각하지 않고 추상적으로 단지 p가 n을 가리키고 있다는 것만 생각해도 이해할 수 있다.
* 포인터를 기반으로 하여 다양한 데이터 구조를 정의하고 사용할 수 있다.
#### 생각해보기
* 💁‍♂ : 포인터의 크기는 메모리의 크기와 어떤 관계가 있을까요?
  * 🙋‍♀️ : 포인터의 크기는 모두 같은 크기를 가집니다.  
    예를 들어 char*, int*, float* 등 모든 포인터 자료형들은 같은 크기를 가지고 있습니다. 포인터는 그저 주소 값을 저장하는 자료형으로, 메모리의 크기와는 관계가 없습니다.  
    16bit 컴파일러에서는 2byte, 32bit 컴파일러에서는 4byte, 64bit 컴파일러에서는 8byte가 포인터의 크기가 됩니다.

### 3️⃣ 문자열
#### 강의 요약
* 문자열의 가장 마지막 \0은 0으로 이루어진 바이트로, 문자열의 끝을 표시하는 약속이다.
* 문자열은 문자의 배열이다.
  ``` C
  #include <stdio.h>

  int main(void)
  {
      char *s = "EMMA";
      printf("%s\n", s);
  }
  ```
  * s[0], s[1], s[2], … 와 같이 하나의 문자가 배열의 한 부분을 나타낸다.
  * 변수 s는 이러한 문자열을 가리키는 포인터가 된다.
    * 문자열의 가장 첫번째 문자, 즉 해당 주소에 있는 s[0]를 가리키게 된다.
#### 생각해보기
* 💁‍♂ : string 자료형을 정의해서 사용하면 어떤 장점이 있을까요?
  * 🙋‍♀️ : 코드를 공유하는 사람들과 약속을 하여 정의를 하였다면 쉽게 의미가 통하고 가독성이 높아지게 됩니다.

### 4️⃣ 문자열 비교
#### 강의 요약
``` C
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
}
```
* 위 코드를 실행하면, s라는 포인터의 값, 즉 "EMMA"라는 문자열의 가장 첫 값인 'E'에 해당하는 메모리 주소를 출력한다.
``` C
printf("%p\n", &s[0]);
printf("%p\n", &s[1]);
printf("%p\n", &s[2]);
printf("%p\n", &s[3]);
```
* 위 코드를 실행하면, s라는 문자열의 첫 번째 문자에 해당하는 주소값, s라는 문자열의 두 번째 문자에 해당하는 주소값, s라는 문자열의 세 번째 문자에 해당하는 주소값, s라는 문자열의 네 번째 문자에 해당하는 주소값을 출력한다.
  * 상단 코드와 이어 생각한다면 &s[0]는 “E”의 주소값을, &s[1]은 “M”의 주소값을,  &s[2]은 “M”의 주소값을,  &s[3]은 “A”의 주소값을 의미한다.
  * 문자열은 첫번째 문자를 시작으로 메모리상에서 바로 옆에 저장되어 있다.
  * 다시 말해, 가장 첫 번째 문자에 해당하는 주소값을 하나씩 증가시키면 바로 옆에 있는 문자의 값을 출력할 수 있다.
    ``` C
    printf("%c\n", *s);
    printf("%c\n", *(s+1));
    printf("%c\n", *(s+2));
    printf("%c\n", *(s+3));
    ```
``` C
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자로부터 s와 t 두 개의 문자열 입력받아 저장
    string s = get_string("s: ");
    string t = get_string("t: ");

    // 두 문자열을 비교 (각 문자들을 비교)
    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```
* 문자열을 비교할 때, 위 코드와 같이 문자열이 저장된 변수를 바로 비교하게 되면 그 변수가 저장되어 있는 주소가 다르기 때문에 다르다는 결과가 나온다.
  * 정확한 비교를 위해서는 실제 문자열이 저장되어 있는 곳으로 이동하여, 각 문자를 하나씩 비교해야 된다. 
#### 생각해보기
* 💁‍♂ : 문자열을 비교하는 코드는 어떻게 작성해야 할까요?
  * 🙋‍♀️ : strcmp 함수를 이용하여 비교합니다.  
    int strcmp(const char *str1, const char *str2)

### 5️⃣ 문자열 복사
#### 강의 요약
``` C
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```
* 두 문자열을 실제로 메모리상에서 복사하려면 위 코드와 같이 메모리 할당 함수를 사용해야 한다.
  * 아래는 위 코드의 흐름이다. 
    1. malloc이라는 함수를 이용해 t를 정의한다.
       * malloc이라는 함수를 정해진 크기만큼 메모리를 할당하는 함수이다.
       * s 문자열의 길이에 널 종단 문자(\0)에 해당하는 1을 더한 만큼 메모리를 할당한다.
    2. 루프를 돌면서 s 문자열에 있는 문자 하나 하나를 t 배열에 복사해준다.
    3. 위 코드를 실행시켜 입력값으로 "emma"를 주면 s는 "emma", t는 "Emma"가 출력된다.
#### 생각해보기
* 💁‍♂ : 배운 바와 같이 메모리 할당을 통해 문자열을 복사하지 않고, 단순히 문자열의 주소만 복사했을 때는 어떤 문제가 생길까요?
  * 🙋‍♀️ : 단순히 문자열 주소만 복사했을 경우, 복사한 문자열을 변경 삭제 등 가공작업을 할 때 결국 원본을 가르키는 것이기 때문에 원본 손상이 있을 수 있습니다.  
    따라서 원본을 유지하고 복사본으로 문자열을 가공하고자 할 때는 메모리 할당을 통해 문자열을 복사해야 합니다.

### 6️⃣ 메모리 할당과 해제
#### 강의 요약
* malloc 함수를 이요하여 메모리를 할당한 후에는 free 함수를 이용해 메모리를 해제해줘야 한다.
  * 그렇지 않은 경우, 메모리에 저장한 값은 쓰레기 값으로 남게 되어 메모리 용량의 낭비가 발생하기 떄문이다. 
    * 이러한 현상을 '메모리 누수'라고 일컫는다.
``` C
#include <stdlib.h>

void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;
}

int main(void)
{
    f();
    return 0;
}
```
* 위 코드를 살펴보자.
  * f 함수를 보면 먼저 포인터 x에는 int의 사이즈(4바이트)에 10배에 해당하는 크기의 메모리, 즉 40바이트를 할당한다.
    * 그리고 x의 10번째 값으로 0을 할당한다.
  * main 함수에서 f를 실행하게 되는데, 이 코드는 버퍼 오버플로우와 메모리 누수 두가지 문제점이 있다.
    * 버퍼 오버플로우는 `x[10] = 0;`로 인해 발생한다.
      * 사이즈 10의 int형 배열을 만들었는데, 배열의 인덱스 10은 11번째 인덱스에 접근하므로 이는 정의되지 않은 것이기 때문에 버퍼 오버플로우가 발생한다.
      * 이는 0에서 9사이의  인덱스를 사용하면 해결할 수 있다.
    * 메모리 누수는 x라는 포인터를 통해 할당한 메모리를 해제하지 않았기 때문에 발생한다.
      * `free(x);`라는 코드를 추가해줌으로써 해결할 수 있다.
#### 생각해보기
* 💁‍♂ : 제한된 메모리를 가지고 프로그래밍을 할 때 메모리를 해제하지 않으면 어떤 문제가 발생할 수 있을까요?
  * 🙋‍♀️ : 힙 메모리에서 누수가 발생하여 메모리 낭비가 되어 성능이 저하됩니다.  
    프로그램이 끝나면 자동으로 메모리를 해제 기능을 지원하는 OS들이 있지만 그렇지 않은 OS에 대응하기 위해서는 메모리 해제가 습관 되어야 합니다.

### 7️⃣ 메모리 교환, 스택, 힙
#### 강의 요약
* 아래 코드를 실행하면, 값을 바꾸는 swap 함수를 거친 후에도 x와 y의 값이 바뀌지 않은채 그대로 출력된다.
  ``` C
  #include <stdio.h>

  void swap(int a, int b);

  int main(void)
  {
      int x = 1;
      int y = 2;

      printf("x is %i, y is %i\n", x, y);
      swap(x, y);
      printf("x is %i, y is %i\n", x, y);
  }

  void swap(int a, int b)
  {
      int tmp = a;
      a = b;
      b = tmp;
  }
  ```
  * swap 함수는 교환 작업이 수행되지만, 문제는 교환하는 대상이 x, y 자체가 아닌 함수 내에서 새롭게 정의된 a,b라는 것이다.
    * a와 b는 각각 x와 y의 값을 복제하여 가지게 된다. 즉, 서로 다른 메모리 주소에 저장된다. 
* 메모리 안에는 데이터가 저장되는 구역이 나뉘어 있다.
  * 머신 코드 영역, 글로벌 영역, 힙 영역, 스택 영역이 있다.
    * 머신 코드 영역에는 프로그램이 실행될 때 그 프로그램이 컴파일된 바이너리가 저장된다.
    * 글로벌 영역에는 프로그램 안에서 저장된 전역 변수가 저장된다.
    * 힙 영역에는 malloc으로 할당된 메모리의 데이터가 저장된다.
    * 스택 영역에는 프로그램 내의 함수와 관련된 것들이 저장된다. 
* 메모리 구역을 바탕으로 다시 생각해보면, 상단 코드에서 a, b, x, y, tmp 모두 스택 영역에 저장되지만 a와 x, b와 y는 그 안에서도 서로 다른 위치에 저장된 변수이다.
  * 따라서 a와 b를 바꾸는 것은 x와 y를 바꾸는 것에 아무런 영향도 미치지 않는다. 
  * a와 b를 각각 x와 y를 가리키는 포인터로 지정함으로써 해당 문제를 해결할 수 있다.
    ``` C
    #include <stdio.h>

    void swap(int *a, int *b);

    int main(void)
    {
        int x = 1;
        int y = 2;

        printf("x is %i, y is %i\n", x, y);
        swap(&x, &y);
        printf("x is %i, y is %i\n", x, y);
    }

    void swap(int *a, int *b)
    {
        int tmp = *a;
        *a = *b;
        *b = tmp;
    }
    ```
* 오버플로우
  * 힙 영역에서는 malloc에 의해 메모리가 더 할당될수록, 점점 사용하는 메모리의 범위가 아래로 늘어난다.
  * 스택 영역에서도 함수가 더 많이 호출될수록 사용하는 메모리의 범위가 점점 위로 늘어난다.
  * 이렇게 점점 범위가 늘어나다 보면 제한된 메모리 용량 하에서는 기존의 값을 침범하는 상황도 발생한다.
    * 이를 힙 오버플로우 또는 스택 오버플로우라고 일컫는다.
#### 생각해보기
* 💁‍♂ : 메모리 영역을 다양하게 나누는 이유는 무엇일까요?
  * 🙋‍♀️ : 메모리는 한정되어 있으므로, 메모리를 할당 받아야하는 데이터들의 목적들에 따라 영역 나누어 접근속도를 빨리하며 관리에 용이하도록 만들기 위함입니다.
#### 배운점
> 메모리 구역에 대해서 쓰임새를 알 수 있어서 좋았다.  
> 강의에 설명에 있는 그림을 통해 오버플로우를 더욱 쉽고  이해할 수 있었다.

### 8️⃣ 파일 쓰기
#### 강의 요약
* 사용자에게 입력 받기
  * scanf라는 함수는 사용자로부터 형식 지정자에 해당되는 값을 입력받아 저장하는 함수이다.
    * `int x;` `scanf("%i", &x);`
      * scanf에 x가 아닌 &x로 그 주소를 입력한다.
      * scanf 함수의 변수가 실제로 스택 영역 안에 x가 저장된 주소로 찾아가서 사용자가 입력한 값을 저장하도록 하기 위함이다.
    * `char s[5];` `scanf("%s", s);`
      * scanf에 변수 s를 그대로 입력한다.
      * s를 문자열, 즉 char자료형의 배열로 정의하였기 때문이다.
      * clang 컴파일러는 문자 배열의 이름을 포인터처럼 다룬다. 즉 scanf에 s라는 배열의 첫 바이트 주소를 넘겨주는 것이다.
* 파일 쓰기
  ``` C
  #include <cs50.h>
  #include <stdio.h>
  #include <string.h>

  int main(void)
  {
      FILE *file = fopen("phonebook.csv", "a");
      char *name = get_string("Name: ");
      char *number = get_string("Number: ");
      fprintf(file, "%s,%s\n", name, number);
      fclose(file);
  }
  ```
  * fopen 함수를 이용하면 FILE 자료형으로 불러올 수 있다.
    * fopen 함수의 첫번째 인자는 파일의 이름, 두번째 인자는 모드로 r은 읽기, w는 쓰기, a는 덧붙이기를 의미한다.
  * 사용자에게 name과 number라는 문자열을 입력받고, 이를 fprintf 함수를 이용하여 printf처럼 파일에 직점 내용을 출력할 수 있다.
  * 작업이 끝난 후에는 fclose 함수로 파일에 대한 작업을 종료해줘야 한다.
#### 생각해보기
* 💁‍♂ : get_long, get_float, get_char도 비슷한 방식으로 직접 구현할 수 있을까요?
  * 🙋‍♀️ : scanf를 활용하여 충분히 가능합니다. long, float, char 뿐만 아니라 short, double 자료형도 가능합니다.  
    scanf("%li", &(long형 변수));  
    scanf("%f", &(float형 변수));  
    scanf("%c", &(char형 변수));

### 9️⃣ 파일 읽기
#### 강의 요약
``` C
#include <stdio.h>

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        return 1;
    }

    FILE *file = fopen(argv[1], "r");

    if (file == NULL)
    {
        return 1;
    }
 
   unsigned char bytes[3];
    fread(bytes, 3, 1, file);

    if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
    {
        printf("Maybe\n");
    }
    else
    {
        printf("No\n");
    }
    fclose(file);
}
```
* 위 코드는 파일의 내용을 읽어서 파일의 형식이 JPEG 이미지인지를 검사하는 프로그램이다.
  * main 함수의 매개변수를 보면 사용자로부터 입력을 받는 것을 알 수 있다.
    * 위 코드에서는 파일의 이름을 입력으로 받는다.
    * 만약 argc가 2라면 프로그램이 그대로 진행된다.
  * 입력받은 파일명(argv[1])을 '읽기(r)'모드로 불러온다.
    * 만약 파일이 제대로 열리지 않으면 fopen 함수는 NULL을 리턴하기 때문에 이를 검사하여 file을 제대로 쓸 수 있는지를 검사하고, 아니라면 1을 리턴하고 프로그램을 종료한다.
    * 만약 파일이 잘 열렸다면, 프로그램이 계속 진행된다.
  * 크기가 3인 문자 배열을 만들고, fread 함수를 이용해서 파일에서 첫 3바이트를 읽어온다.
    * fread 함수의 각 인자는 (배열, 읽을 바이트 수, 읽을 횟수, 읽을 파일)을 의미한다.
  * 읽어들인 각 바이트가 각각 0xFF, 0xD8, 0xFF 인지를 확인한다.
    * 이는 JPEG 형식의 파일을 정의할 때 만든 약속으로, JPEG 파일의 시작점에서 꼭 포함되어 있어야 한다.
    * 따라서 이를 검사하면 JPEG 파일인지를 확인할 수 있다.
#### 생각해보기
* 💁‍♂ : JPEG 외에 다른 파일 형식도 그 형식임을 알려주는 약속이 있을까요?
  * 🙋‍♀️ : JPEG 파일 형식에 약속이 있다면 다른 파일형식들에도 약속이 있을 것이며, 그 약속을 통해 파일 포맷들을 해석할 수 있을 것입니다.  
    이렇게 파일 형식들의 고유한 포맷의 기본이 되는 내용을 보고 파일 시그니처, 혹은 매직 넘버라고 합니다.
#### 배운점
> 지금 배우고 생각해보니 어떤 파일 형식을 만들었을 땐 그 파일 형식들에 대한 약속이 있었을 텐데,  
> 그 부분을 생각하지 못하고 예전 프로젝트에서 애를 먹었던 것 같다.  
> 파일 시그니처, 매직 넘버! 이제 꼭 기억해야겠다.

## [💡 퀴즈](https://www.boostcourse.org/cs112/joinLectures/41497)
1. 메모리 주소 - 아래 코드를 실행하면 어떤 결과가 출력될까요?
   ``` C
   #include <stdio.h>

   int main(void)
   {
       int n = 20;
       printf("%i \n", *&n);
   }
   ```
   > 20
2. 포인터 - 아래와 같이 변수 n과 p을 생성했습니다. 변수 n의 메모리 주소를 출력하는 올바른 코드는 다음 중 무엇인가요?
   ``` C
   int n = 5;
   int *p = &n;
   ```
   > printf("%p\n", p);
3. 문자열 - CS50 라이브러리의 string 자료형을 사용해 변수 s를 생성했습니다. 아래와 동일한 의미를 지니는 코드는 무엇인가요?
   ``` C
   string s = "CS50";
   ```
   > char *s = “CS50”
4. 문자열 비교 - 아래와 같이 변수 s를 생성했을때, 문자 ‘W’를 출력하는 코드는 무엇인가요?
   ``` C
   char *s = "EDWITH";
   ```
   > printf("%c\n", *(s+2));
5. 문자열 복사 - 아래와 같이 변수 s를 생성한 뒤, 새로운 변수 t에 “EDWITH” 문자를 복사하려고 합니다. malloc 함수를 이용해 변수 t를 생성할 때 총 몇 바이트의 메모리를 할당해야 할까요?
   ``` C
   char *s = "EDWITH";
   ```
   > 7바이트
6. 메모리 할당과 해제 - 할당된 메모리를 해제 하기 위해 사용하는 함수는 무엇인가요?
   > free()
7. 메모리 교환, 스택, 힙 - malloc() 함수를 통해 할당받은 메모리는 어디에 위치하게 될까요?
   > 힙(heap)
8. 파일 쓰기 - data.csv 파일에 값을 입력하는 프로그램을 작성하려고 합니다. 이때 필요한 함수가 아닌 것은 무엇인가요?
   ```
   fopen(), fcreate(), fprintf(), fclose()
   ```
   > fcreate()
9. 파일 읽기 - 아래와 같은 코드가 있을 때 출력되는 값은 얼마일까요?
   ``` C
   int main(void)
   {
       x = 5;
       func(&x);
       printf("%i", x);
   }

   void func(int *y)
   {
       *y = 10;
   }
   ```
   > 10
10. 메모리 교환 - 아래 코드와 같이 swap 함수를 통해 메모리에 저장된 x와 y의 값을 교환하려고 합니다. 즉, swap 함수가 호출된 이후 x는 5, y는 3의 값을 가져야 합니다. main 함수에서 호출되는 swap 함수의 괄호에 포함되어야 할 코드로 적절한 것은 무엇인가요?
    ``` C
    #include <stdio.h>

    void swap(int *a, int *b);

    int main(void)
    {
        int x = 3;
        int y = 5;
        swap(      );
    }

    void swap(int *a, int *b)
    {
        int tmp = *a;
        *a = *b;
        *b = tmp;
    }
    ```
    > &x, &y

## 🎞 회고  
> 사실 포인터는 처음 배웠을 때 그렇게 어렵게 느껴지진 않았던 개념인데,  
> 오히려 객체지향 언어를 오래하다가 포인터를 다시 보니 까다롭다고 생각되었다.  
> 포인터를 다시 접하면서, 메모리 관리를 할 줄 알아야 한다고 느껴져 C도 꾸준히 사용하여 잊지 않아야 겠다고 생각했다.  
>   
> 또, 학교에서 접했을 때 어렵게 느껴졌던 파일 입출력을 배웠다.  
> 근데 이상하게도 쉬운 예제라서 그런건지 이미 배웠던 것이라 그런건지 정말 쉽고 그냥 입출력과 별반 다르지 않다고 느껴졌었다.  
> 그리고 파일 형식자에 대한 약속들도 알게 되어, 이를 나중에 파일을 관리하게 되는 프로그램을 만들면 유용하게 쓰일 것 같다.  
>   
> 늦게 기록을 하면서 뼈저리게 느낀다. 공부하는 자체가 힘든 게 아니라 기록이 힘들다...  
> 기록이 참... 귀찮게 느껴지고 힘들다... 그래도 기록하는 자세를 가지자..!! 😥😥
