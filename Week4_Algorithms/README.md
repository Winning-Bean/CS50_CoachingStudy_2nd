# 🚀 4주차 - 알고리즘

## [👨‍🏫 강의](https://www.boostcourse.org/cs112/joinLectures/41488)
### 1️⃣ 검색 알고리즘
#### 강의 요약
* 배열은 한 자료형의 여러 값들이 메모리상에 모여있는 구조이다.
  * 컴퓨터는 이 값들에 접근할 때 배열의 인덱스 하나하나를 접근한다.
  * 어떤 값이 배열 안에 속해 있는지 찾아 보기 위해서는 배열이 정렬되어 있는지 여부에 따라 선형 검색과 이진검색 방법을 사용할 수 있다.
* 선형 검색
  * 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사한다.
    ```
    For i from 0 to n–1

        If i'th element is 50

            Return true

    Return false
    ```
* 이진 검색
  * 배열이 정렬되어 있을 때 사용하는 방법이다.
  * 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은(작은 값이 저장되어 있는) 인덱스 또는 큰(큰 값이 저장되어 있는) 인덱스로 이동을 반복하며 검사한다.
    ```
    If no items

        Return false

    If middle item is 50

        Return true

    Else if 50 < middle item

        Search left half

    Else if 50 > middle item

        Search right half
    ```
#### 생각해보기
* 💁‍♂ : 만약 정렬되지 않은 배열이 있다면, 선형 검색이 빠를까요 이진 검색이 빠를까요?
  * 🙋‍♀️ : 어느 검색이 빠르다고 말할 수 없습니다. 정렬되어 있지 않다면 찾는 값이 어느쪽에 있는지 알 수 없기 때문입니다.  
  또한 정렬되지 않은 배열에서 이진 검색을 한다면 크거나 작은 값을 기준으로 검색을 하는 것이 아니라 그저 인덱스의 번호를 기준으로 검색을 해야하며, 한쪽에서 검색이 안 된다면 다른 한쪽으로 또 검색을 해야하는 처리를 해야합니다. 때문에 저라면 정렬되지 않은 배열에서는 선형검색을 택할 것 같습니다.
  
### 2️⃣ 알고리즘 표기법
#### 강의 요약
* Big O
  * 알고리즘 실행 시간의 상한을 나타낸 것
  * O는 "on the order of"의 약자로, 쉽게 생각하면 "~만큼의 정도로 커지는"것이라고 볼 수 있다.
  * O(n)은 n만큼 커지는 것이므로 n이 늘어날수록 선형적으로 증가하게 된다.
    * O(n/2)도 결국 n이 매우 커지면 1/2은 큰 의미가 없어지므로 O(n)이라고 볼 수 있다.
  * 주로 아래 목록과 같은 Big O 표기가 사용된다.
    * O(n^2)
    * O(n log n)
    * O(n) `예) 선형 검색`
    * O(log n) `예) 이진 검색`
    * O(1)
* Big Ω
  * 알고리즘 실행 시간의 하한을 나타낸 것
  * 예를 들어 선형 검색에서는 n개의 항목이 있을 때 최대 n번의 검색을 해야하므로 상한이 O(n)이 되지만 운이 좋다면 한 번만에 검색을 끝낼 수도 있으므로 하한은 Ω(1)이 된다.
  * 주로 아래 목록과 같은 Big Ω 표기가 사용된다.
    * Ω(n^2)
    * Ω(n log n)
    * Ω(n) `예) 배열 안에 존재하는 값의 개수 세기`
    * Ω(log n)
    * Ω(1) `예) 선형 검색, 이진 검색`
#### 강의 요약
#### 생각해보기
* 💁‍♂ : 실행시간의 상한이 낮은 알고리즘이 더 좋을까요, 하한이 낮은 알고리즘이 더 좋을까요?
  * 🙋‍♀️ : 입력값, 주어지는 값이 비슷해서 그에 따라 하한이 낮은 알고리즘의 하한값에 부합하는 프로그램이라면 하한이 낮은 알고리즘이 더 좋은 성능을 보일 것 입니다.  
  하지만 입력값, 주어지는 값이 만약 달라졌을 경우 유지보수에 비용을 쏟아야 하므로 항상 입력값, 주어지는 값이 비슷한 프로그램이 아니라면 실행시간의 상한이 낮은 알고리즘으로 구현해야 장기적으로 좋다고 생각합니다.  
  또한 최악의 상황을 항상 고려해야 하는 프로그램에서는 항상 상한이 낮은 알고리즘을 선택해야 합니다.

## [💡 퀴즈](https://www.boostcourse.org/cs112/joinLectures/41496)
## 🎞 회고
