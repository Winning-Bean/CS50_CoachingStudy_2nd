# 🚀 3주차 - 배열

## [👨‍🏫 강의](https://www.boostcourse.org/cs112/joinLectures/41487)
### 1️⃣ 컴파일링
#### 강의 요약
* make나 clang을 사용해서 프로그램을 실행할 때 네 개의 단계를 거친다.
  1. 전처리
  2. 컴파일링
  3. 어셈블링
  4. 링킹
1. 전처리(Precompile)
    * 전처리기에 의해 수행된다.
    * \# 으로 시작되는 C 소스 코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려준다. `예) #include`
       * #include는 전처리기에게 다른 파일의 내용을 포함시키라고 알려준다.  
          전처리기는 새로운 파일을 생성하는데, 해당 파일은 여전히 C 소스 코드 형태이며 해당 파일의 내용이 #include 부분에 포함된다.
2. 컴파일(Compile)
    * 컴파일이라는 용어는 소스 코드에서 오브젝트 코드로 변환하는 과정을 통틀어 일컫기도 하지만, 구체적으로 전처리한 소스 코드를 어셈블링 코드로 변환시키는 단계를 말하기도 한다.
    * 컴파일러가 C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일한다.
    * 어셈블리는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있다.
    * C를 어셈블리 코드로 변환시켜줌으로써 컴파일러는 전처리 소스 코드를 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만들어 준다.
3. 어셈블(Assemble)
    * 어셈블러가 어셈블리 코드를 오브젝트 코드로 변환시키는 단계이다.
    * 컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 연속된 0과 1들로 바꿔주는 작업이다.
    * 소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 어셈블 단계에서 끝난다.
4. 링크(Link)
    * 만약 프로그램이 라이브러리를 포함해 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크 단계가 필요하다.
    * 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다.
      * 예) 컴파일을 하는 동안 A 라이브러리를 링크하면 오브젝트 코드는 A의 functionA()나 functionB() 같은 함수를 어떻게 실행할 지 알 수 있게 된다.
* 위의 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성된다.
#### 생각해보기
* 💁‍♂ : 만약 컴파일링 과정을 거치지 않기 위해 바로 머신코드로 우리가 원하는 프로그램을 작성하려고 한다면 어떤 문제가 있을까요?
  * 🙋‍♀️ : 코드 작성이 어려워지고 가독성이 많이 떨어지며 그에 따라 유지보수 또한 어려워집니다.
#### 배운점
> 전처리기에서 새로운 파일을 생성한다는 사실은 몰랐던 것 같다.  
> 새로운 파일을 컴파일하고 어셈블하고, 또 링크해야 하는 과정을 강의 내용을 통해 직관적으로 볼 수 있어 쉽게 이해됐던 것 같다.

### 2️⃣ 디버깅
#### 강의 요약
* 버그(bug)
  * 버그는 코드에 들어있는 오류이다.
  * 버그로 인해 프로그램의 실행에 실패하거아 프로그래머가 원하는 대로 동작하지 않게 된다.
* 디버깅(debugging)
  * 디버깅은 코드에 있는 버그를 식별하고 고치는 과정을 말한다.
  * 프로그래머는 디버거라고 불리는 프로그램을 사용하여 디버깅을 하게 된다.
* 디버깅의 기본
  * 프로그램은 일반적으로 빠른 연산을 수행하기 때문에 프로그램을 실행시켜보는 것만으로는 무엇이 잘못됐는지 찾기 어렵다.
  * 디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움이 된다.
  * **프로그램이 멈추는 특정 지점을 중지점이라고 한다.**
  * 프로그래머는 멈춰진 중지점에서 무슨 일이 일어나는지 볼 수 있다.
    * 이로써 프로그램이 내리는 모든 결정들을 단계별로 따라갈 수 있게 된다.
#### 생각해보기
* 💁‍♂ : 디버깅을 도와주는 프로그램은 어떤 경우에 더 큰 도움이 될까요? 만약 이런 프로그램의 도움 없이 직접 디버깅을 해야 한다면 어떻게 코드를 작성하는 것이 좋을까요?
  * 🙋‍♀️ : 디버깅을 도와주는 프로그램은 코드가 방대해지고 복잡한 프로그램을 디버깅 할 때 어느 부분에서 문제가 있는지 유추하기에 큰 도움이 됩니다. 또한 프로그램의 도움 없이는 각 함수나 문제가 있다고 유추되는 단계마다 로그를 남겨 직접 확인해가며 디버깅을 해야합니다.
#### 배운점
> 디버깅이라는 개념은 옛날에 정말 어렵게만 느껴졌었던 개념인 것 같다.  
> 이번 강의를 통해 간단하게 디버깅의 개념을 짚고 넘어가서 좋았다.
> 프로그램이 복잡해지고 거대해질 수록 디버깅 능력도 더욱 중요해진다고 생각이 드는만큼 이를 잘 숙지해야겠다!

### 3️⃣ 코드의 디자인
#### 강의 요약
* 코드의 디자인
  * 공백의 수나 줄바꿈 같은 것들은 코드의 실행에 직접적으로 영향을 주지는 않지만 코드를 작성하는 사람들이 코드를 읽고 이해하는데 영향을 준다.
  * 아래와 같이 for 루프를 작성할 때도 사람에 따라 여러 방식으로 작성할 수 있다.
    ``` C
    for (int i = 0; i <= 10; i++)
        {
            printf("#\n");
        }
    ```

    ``` C
    for (int i = 0; i <= 10; i++){
        printf("#\n");
    }
    ```

    ``` C
    for (int i = 0; i <= 10; i++){ printf("#\n"); }
    ```
  * 많은 회사들은 사내에서 코드를 작성할 때 특정한 스타일 가이드를 따르도록 한다.
    * 여러 사람들이 코드를 작성하기 때문에 서로 불필요한 오해를 없애고, 코드를 이해하는 데 드는 비용을 최소화하기 때문이다.
  * 모든 언어들은 각각 표준 코딩 스타일 가이드가 있다.
  > 개발자는 코드를 작성하는 시간보다 읽는 데에 시간을 더 많이 쓴다는 통계가 있다고 한다.
* 고무 오리(Rubber duck)
  * 가끔은 코드에 포함된 오류를 해결할 때 디버거같은 프로그램이 존재하지 않거나, 있다고 하더라도 디버깅에 큰 도움이 되지 않을 때도 있다.
  * 이때는 유명한 방법으로 '고무 오리'와 같ㅇ이 무언가 대상이 되는 물체를 앞에 두고, 작성한 코드를 한 줄 한 줄 말로 설명해주는 과정을 거쳐볼 수 있다.
  * 이를 통해 미처 놓고 있었던 논리적 오류를 찾아낼 수도 있다.
#### 생각해보기
* 💁‍♂ : 만약 여러 사람들이 함께 참여하는 프로젝트에서, 각자가 작성하는 코드 스타일 서로 다르다면 어떤 비효율적인 일이 발생할까요?
  * 🙋‍♀️ : 정해진 규격이 아니기 때문에 코드를 이해하거나 수정할 때 시간이 더욱 오래걸리고, 전체적인 코드의 가독성이 떨어지게 됩니다.
#### 배운점
> 함께하는 프로젝트에서는 가독성과 유지보수를 위해 코드 스타일을 맞추는 게 중요한 것 같다.  
> 예전에는 변수명, 함수명 등 명명에서만 이런 부분을 신경썼었는데, 현재 진행하고 있는 알고리즘 스터디에서 다른 사람들의 코드를 보니  
> 루프문과 조건문부터 개행까지 서로의 스타일이 다르니 읽는데 좀 더 많은 시간이 걸린다는 것을 많이 느꼈었다.  
> 적어도 한 프로젝트 내에서는 같은 규격을 가진 스타일대로 코드를 작성해야지 서로의 코드를 이해하고 유지보수 하는데 적은 비용이 들 것이라고 생각한다.  
>  
> 러버덕 디버깅을 처음 들어보는 말이라서 꽤나 재밌다고 생각하면서 봤던 것 같다.   
> '러버덕 디버깅' 자체는 몰랐지만 항상 하고 있는 방법이다. 대상은 컴퓨터...  
> 새로운 용어를 배워 재밌었고 나만의 코드 설명 친구를 만들고 싶었다 ^^

### 4️⃣ 배열(1)
#### 강의 요약
* 메모리
  * C에는 여러 자료형이 있고, 각각의 자료형은 서로 다른 크기의 메모리를 차지한다.
    * bool : 불리언, 1바이트
    * char : 문자, 1바이트
    * int : 정수, 4바이트
    * float : 실수, 4바이트
    * long : (더 큰) 정수, 8바이트
    * double : (더 큰) 실수, 8바이트
    * string : 문자열, ?바이트
  * 컴퓨터 안에는 RAM이라고 하는 물리적 칩이 메모리 역할을 한다.
* 배열
  * 같은 자료형의 데이터를 메모리상에서 연이어서 저장하고 이를 하나의 변수로 관리하기 위해 사용된다.
  * 예를 들어, `int arr[3];`이라는 코드는 int 자료형을 가지는 크기 3의 배열을 arr라는 이름으로 생성하겠다는 의미이다.
    * 배열의 인덱스는 0부터 시작하기 때문에 arr의 인덱스는 0, 1, 2 세 개가 있다.
  * 인덱스를 변수명 뒤 대괄호 사이에 입력하여 배열의 원하는 위치에 원하는 값을 저장하고 불러올 수 있다.
#### 생각해보기
* 💁‍♂ : 실생활의 어떤 데이터를 배열로 표현할 수 있을까요?
  * 🙋‍♀️ : 하나의 주제 안에 여러 데이터가 쓰이는 경우 하나의 배열로 표현할 수 있습니다.  
  가령 시험의 답안 목록들은 시험 답안이라는 주제에 묶에 있기 때문에 배열로 표현할 수 있으며, CS50의 팀별 인원 수 또한 같은 맥락으로 배열로 표현할 수 있습니다.
  
### 5️⃣ 배열(2)
#### 강의 요약
* 전역 변수
  * 만약 어떤 변수가 고정된 값(상수)이라면 그 값을 선언할 때 'const'를 앞에 붙여서 전여 변수, 즉 코드 전반에 거쳐 바뀌지 않는 값임을 지정해줄 수 있다.
  * 관례적으로 전역 변수의 이름은 대문자로 표기한다.
* 배열의 동적 선언 및 저장
  * 루프와 함수를 선언해 좀 더 동적인 프로그램을 작성할 수 있다.
  * 배열의 크기를 사용자에게 직접 입력 받고, 배열의 크기만큼 루프를 돌면서 각 인덱스에 해당하는 값을 사용자에게 동적으로 입력받아 저장할 수 있다.
  * 이와 같은 방법을 통해 프로그램을 동적으로 작성할 수 있다.
#### 생각해보기
* 💁‍♂ : 점수의 평균을 구하는 예제에서, 동적으로 작성한 코드는 그렇지 않은 코드에 비해 어떤 장단점이 있을까요?
  * 🙋‍♀️ : 사용자가 입력하는 값에 따라 결과가 달라질 수 있어 실사용에 유용합니다.  
  하지만 사용자의 입력값이코드의 예상에서 벗어났을 때 오류가 발생할 수 있어 예외처리등을 신경써야 합니다.

### 6️⃣ 문자열과 배열
#### 강의 요약
* 문자열은 문자 자료형 데이터들의 배열이다.
* \\0
  * 문자열의 끝을 나타내는 널 종단 문자
  * 단순히 모든 비트가 0인 1바이트를 의미한다.
* 문자열 형식의 배열은 `arr[i][j]`처럼 2차원 배열을 통해 접근할 수 있다.
#### 생각해보기
* 💁‍♂ : 널 종단 문자는 왜 필요할까요?
  * 🙋‍♀️ : 문자열의 끝을 알리기 위해서 필요합니다.

### 7️⃣ 문자열의 활용
#### 강의 요약
* 문자열의 길이 및 탐색
  * 문자열의 끝을 알 수 있는 방법
    * 인덱스의 문자가 널 종단 문자와 일치하는지 검사하는 것
    * strlen()이라는 함수 사용
  * strlen은 문자열의 길이를 알려주는 함수이다.
    * string.h 라이브러리 한에 포함되어있다.
* 문자열 탐색 및 수정
  * 문자열의 각 인덱스에 해당하는 문자가 'a'보다 크고 'z'보다 작은지 검사하여 소문자인지 검사할 수 있다.
    * 문자의 대소비교가 가능한 이유는 ASCII값, 즉 문자가 정의되는 ASCII 코드 상에서의 숫자값으로 비교할 수 있기 때문이다.
    * 알파벳의 소문자와 대문자는 32씩 차이난다.
      * 소문자에서 32를 빼면 대문자
      * 대문자에서 32를 더하면 소문자
      * 위와 동일한 작업을 수행하는 함수가 ctype.h 라이브러리에 toupper(), tolower()이라는 함수로 정의되어 있다.
#### 생각해보기
* 💁‍♂ : string.h와 ctype.h의 라이브러리에 다른 어떤 함수가 있는지 확인해 보고, 어떤 함수를 어떻게 활용해 볼 수 있을지 생각해봅시다.
  * 🙋‍♀️ :
    ```
    string.h에 정의된 함수 : 문자열을 다룰 때 쓰임
    1. memchr () : 특정 문자 메모리 첫번째 발생 검색
    2. memcmp() : 두 문자열의 메모리 비교
    3. memcpy() : 메모리의 특정 문자 복사
    4. memmove() : 메모리의 특정 문자 복사
    5. memset() : 메모리에 특정 문자 복사
    6. strcat() : 문자열 추가
    7. strncat() : 지정한 부분만큼 문자열 추가
    8. strchr() : 문자열에서 특정 문자 위치 구하기
    9. strcmp() : 두 문자열 비교
    10. strncmp() : 두 문자열 지정한 부분만큼 비교
    11. strcoll() : locale을 이용한 두 문자열 비교
    12. strcpy() : 문자열 복사
    13. strncpy() : 지정한 부분문큼 문자열 복사
    14. strcspn() : 특정 문자열에 포함된 문자들을 다른 문자열에서 찾아 가장 먼저 나오는 것을 구하기
    15. strerror() : 내부 배열에서 오류 번호를 검색하고 오류 메시지 문자열에 대한 포인터를 반환
    16. strlen() : 문자열의 길이 계산
    17. strpbrk() : 특정 문자열과 일치하는 다른 문자열에서 첫 번째 문자 찾기 
    18. strrchr() : 문자열에서 특정 문자의 마지막 발생을 검색
    19. strspn() : 특정 문자열로만 구성된 문자열의 초기 세그먼트 길이 계산
    20. strstr() : 문자열에 나타나는 특정문자열의 첫 번째 항목 찾기
    21. strtok() : 문자열을 토큰으로 분리
    22. strxfrm() : local을 이용해  문자열을 변환

    ctype.h에 정의된 함수 : 문자들을 조건에 맞는지 검사하고 변환할 때 쓰임
    1. isalnum() : 영숫자인지 확인
    2. isalpha() : 알파벳인지 확인
    3. iscntrl() : 제어 문자인지 확인
    4. isdigit() : 10진수인지 확인
    5. isgraph() : 그래픽 표현이 있는지 확인
    6. islower() : 소문자인지 확인
    7. isprint() 인쇄 가능한지 여부 확인
    8. ispunct() : 구두점 문자인지 확인
    9. isspace() : 공백인지 여부 확인
    10. isupper() : 대문자인지 확인
    11. isxdigit() : 16진수인지 확인
    12. tolower() : 대문자를 소문자로 변환
    13. toupper() : 소문자를 대문자로 변환
    ```

### 8️⃣ 명령행 인자
#### 강의 요약
* 명령행 인자
  ``` C
  #include <cs50.h>
  #include <stdio.h>

  int main(int argc, string argv[])
  {
      if (argc == 2)
      {
          printf("hello, %s\n", argv[1]);
      }
      else
      {
          printf("hello, world\n");
      }
  }
  ```
  * argc는 main 함수가 받게 될 입력의 개수이다.
  * argv[]는 그 입력이 포함되어 있는 배열이다.
  * 프로그램을 명령행에서 실행하므로, 입력은 문자열로 주어진다.
    * 따라서 argv[]는 string 배열이 된다.
  * argv[0]는 기본적으로 프로그램의 이름으로 저장된다.
    * 위 프로그램을 "argc"라는 이름으로 저장하고 컴파일 후 `./argc`로 실행하면 "hello, world"라는 값이 출력된다.
      * 명령행 인자에 주어진 값이 프로그램 이름 하나밖에 없기 때문이다.
    * `./argc WSB`으로 실행해보면 "hello, WSB"라는 값이 출력된다.
      * 명령행 인자에 WSB이라는 값이 추가로 입력되었고, 따라서 argc는 2, argv[1]은 "WSB"이 되기 때문이다.
#### 생각해보기
* 💁‍♂ : 명령행 인자는 프로그램의 확장성에 어떤 도움이 될까요? 구체적인 예시를 떠올려보세요.
  * 🙋‍♀️ : 사용자에게 입력을 바로 받을 수 있어 동적인 프로그램을 제작할 수 있으며 이에 따라 확장성이 높아집니다.  
  또한 명령행 인자의 변수 자체를 활용하여 프로그램의 소스코드를 간결하게 만들 수 있습니다.
#### 배운점
> 명령행 인자...! 그동안 main 함수에 대한 별 생각 없이 타이핑만 쳤던 것 같은데 이렇게 응용할 수 있는지 몰랐다.  
> 명령행 인자에 대한 이해로 그동안 어떻게 작동되는 거지? 하고 신기해 했던 프로그램의 구동 방식을 이해하게 되었다.

## [💡 퀴즈](https://www.boostcourse.org/cs112/joinLectures/41495)
1. 컴파일링 - 컴파일링의 네 단계에 해당하지 않는 것은 무엇인가요?
    > 디버깅(debugging)
2. 디버깅 - 소스코드 내에 존재하는 오류를 해결하기 위한 작업을 무엇이라고 하나요?
    > 디버깅(debugging)
3. 스타일 가이드 - 아래 코드는 기능상으로는 문제가 없지만 C 언어 스타일 가이드에는 부합하지 않습니다. 어떻게 변경하면 스타일 가이드에 부합한 코드가 될까요?
    ``` C
    int main(void)
    {
    printf("hello, world\n");
    }
    ```
    > printf 함수를 들여쓰기해서 중괄호{} 사이에 포함되었음을 표현한다.
4. 배열 - char 자료형을 5개 담을 수 있는 [edwith]라는 이름의 배열을 선언하는 코드는 무엇인가요?
    > char edwith[5];
5. 배열 - int scores[10]; 이라는 배열이 선언되어 있습니다. 이 배열의 처음부터 끝 인덱스까지 순환하는 for 루프는 무엇인가요?
    > for (int i = 0; i < 10; i++) {... scores[i] ...}
6. 배열
    ``` C
    string names[2];
    names[0] = "MONSTER";
    names[1] = "MOM";
    ```
    위와 같은 코드가 주어졌을 때 아래 보기 중 그 값이 다른 것은 무엇일까요?
    ``` C
    names[0][0], names[1][0], names[0][2], names[1][2]
    ```
    > names[0][2]
7. 배열 - 아래와 같은 main 함수를 지니는 edwith.c 코드소스를 작성하고 컴파일했습니다. '$ ./edwith hello world'를 실행하였을 때 argc의 값은 무엇일까요?
    ``` C
    int main(int argc, string argv[])
    {
      ...
    }
    ```
    > 3
8. 컴파일링 자동화 - C 소스파일의 링크, 컴파일, 빌드 작업을 자동화해주는 툴은 다음 중 무엇인가요?
    > make
9. 코드 내의 오류 - 소스코드를 작성할 때 우리가 의식적으로 또는 무의식적으로 저지른 실수나 오류를 통상적으로 일컫는 단어는 무엇인가요?
    > 버그(bug)
10. 문자열의 저장 방식 - 다음 중 문자열(string)이 메모리에 저장되는 방식에 대한 설명으로 틀린 것은 무엇인가요?
    ```
    문자열(string)은 문자(char)의 배열로 저장된다
    문자열(string)의 각 문자(char)는 메모리상에 연이어서 저장된다
    문자열(string)은 포함된 문자(char) 개수 만큼의 메모리 자리를 차지한다
    문자열(string)의 끝에는 널(NUL) 종단 문자가 포함된다
    ```
    > 문자열(string)은 포함된 문자(char) 개수 만큼의 메모리 자리를 차지한다
