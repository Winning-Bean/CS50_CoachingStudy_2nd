# 🚀 5주차 - 메모리

## [👨‍🏫 강의](https://www.boostcourse.org/cs112/joinLectures/41489)
### 1️⃣ 메모리 주소
#### 강의 요약
* 16진수
  * 컴퓨터과학에서는 10진수나 2진수 대신 16진수(Hexadecimal)로 표현하는 경우가 많다.
  * 16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있다.
  * 2^4이 16이기 때문에 4bits씩 2진수의 0000부터 1111까지 16진수로 표현할 수 있다.
  * 10은 a, 11은 b, …, 15는 f를 대입하여 사용한다.
  * 4bits씩 16진수로 변환 후 0x를 붙여 뒤에 오는 문자들이 16진수임을 알려준다.
* 16진수의 유용성
  * 16진수로 표현하면 2진수로 표현했을 때보다 훨씬 간단해진다.
  * 2개의 16진수는 1byte의 2진수로 변환되기 때문에 정보를 표현하기에 매우 유용하다.
    * 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현한다.
* 메모리 주소
  * C에서는 변수의 메모리상 주소를 받기 위해 '&' 연산자를 사용할 수 있다.
    ``` C
    #include <stdio.h>

    int main(void)
    {
        int n = 50;
        printf("%p\n", &n);
    }
    ```
    * 위 코드를 실행하면 메모리상 주소값을 얻을 수 있고, 이는 변수 n의 16진법으로 표현된 메모리의 주소이다.
  * '\*' 연산자를 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있다.
    ``` C
    #include <stdio.h>

    int main(void)
    {
        int n = 50;
        printf("%i\n", *&n);
    }
    ```
    * 위 코드는 먼저 n의 주소를 얻고, 또 다시 그 주소에 해당하는 값을 얻어와 출력한 것이므로 결국 '50'이라는 값이 출력된다.
#### 생각해보기
* 💁‍♂ : 'CS50'을 16진수로 표현해볼까요?
  * 🙋‍♀️ : 0x43 0x53 0x26 0x21 -> 0x43533530  
    > 아스키코드 숫자표를 잘못 봄 & 컴퓨터는 바이트 단위로 정보를 표현하기 때문에 맨 처음에만 0x 표시를 해도 된다는 것을 인지하지 못 함.

### 2️⃣ 포인터
#### 강의 요약
* '\*' 연산자를 이용해 포인터 역할을 하는 변수를 선언할 수 있다.
  ``` C
  #include <stdio.h>

  int main(void)
  {
     int n = 50;
     int *p = &n;
     printf("%p\n", p);
     printf("%i\n", *p);
  }
  ```
  * 위 코드를 보면 정수형 변수 n에 50이라는 값이 저장되어 있다.
  * \*p라는 포인터 변수에 &n 이라는 값, 즉 변수 n의 주소를 저장한다.
  * int \*p에서 p앞의 \*는 해당 변수가 포인터라는 의미고, int는 이 포인터가 int타입의 변수를 가리킨다는 의미이다.
    * 첫번째 printf문과 같이 포인터 p의 값, 즉 변수 n의 주소를 출력할 수 있다.
    * 두번째 printf문과 같이 포인터 p가 가리키는 변수의 값, 즉 n의 값을 출력할 수 있다.
  * 실제 컴퓨터 메모리에서는 p는 가르키는 주소값, 즉 변수 n의 주소값이 저장되어 있고, n은 50이라는 값이 저장되어 있다.
    * 하지만 실제로 p의 값, 즉 n의 주소값을 생각하지 않고 추상적으로 단지 p가 n을 가리키고 있다는 것만 생각해도 이해할 수 있다.
* 포인터를 기반으로 하여 다양한 데이터 구조를 정의하고 사용할 수 있다.
#### 생각해보기
* 💁‍♂ : 포인터의 크기는 메모리의 크기와 어떤 관계가 있을까요?
  * 🙋‍♀️ : 포인터의 크기는 모두 같은 크기를 가집니다.  
    예를 들어 char*, int*, float* 등 모든 포인터 자료형들은 같은 크기를 가지고 있습니다. 포인터는 그저 주소 값을 저장하는 자료형으로, 메모리의 크기와는 관계가 없습니다.  
    16bit 컴파일러에서는 2byte, 32bit 컴파일러에서는 4byte, 64bit 컴파일러에서는 8byte가 포인터의 크기가 됩니다.

### 3️⃣ 문자열
#### 강의 요약
* 문자열의 가장 마지막 \0은 0으로 이루어진 바이트로, 문자열의 끝을 표시하는 약속이다.
* 문자열은 문자의 배열이다.
  ``` C
  #include <stdio.h>

  int main(void)
  {
      char *s = "EMMA";
      printf("%s\n", s);
  }
  ```
  * s[0], s[1], s[2], … 와 같이 하나의 문자가 배열의 한 부분을 나타낸다.
  * 변수 s는 이러한 문자열을 가리키는 포인터가 된다.
    * 문자열의 가장 첫번째 문자, 즉 해당 주소에 있는 s[0]를 가리키게 된다.
#### 생각해보기
* 💁‍♂ : string 자료형을 정의해서 사용하면 어떤 장점이 있을까요?
  * 🙋‍♀️ : 코드를 공유하는 사람들과 약속을 하여 정의를 하였다면 쉽게 의미가 통하고 가독성이 높아지게 됩니다.

### 4️⃣ 문자열 비교
#### 강의 요약
``` C
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
}
```
* 위 코드를 실행하면, s라는 포인터의 값, 즉 "EMMA"라는 문자열의 가장 첫 값인 'E'에 해당하는 메모리 주소를 출력한다.
``` C
printf("%p\n", &s[0]);
printf("%p\n", &s[1]);
printf("%p\n", &s[2]);
printf("%p\n", &s[3]);
```
* 위 코드를 실행하면, s라는 문자열의 첫 번째 문자에 해당하는 주소값, s라는 문자열의 두 번째 문자에 해당하는 주소값, s라는 문자열의 세 번째 문자에 해당하는 주소값, s라는 문자열의 네 번째 문자에 해당하는 주소값을 출력한다.
  * 상단 코드와 이어 생각한다면 &s[0]는 “E”의 주소값을, &s[1]은 “M”의 주소값을,  &s[2]은 “M”의 주소값을,  &s[3]은 “A”의 주소값을 의미한다.
  * 문자열은 첫번째 문자를 시작으로 메모리상에서 바로 옆에 저장되어 있다.
  * 다시 말해, 가장 첫 번째 문자에 해당하는 주소값을 하나씩 증가시키면 바로 옆에 있는 문자의 값을 출력할 수 있다.
    ``` C
    printf("%c\n", *s);
    printf("%c\n", *(s+1));
    printf("%c\n", *(s+2));
    printf("%c\n", *(s+3));
    ```
``` C
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자로부터 s와 t 두 개의 문자열 입력받아 저장
    string s = get_string("s: ");
    string t = get_string("t: ");

    // 두 문자열을 비교 (각 문자들을 비교)
    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```
* 문자열을 비교할 때, 위 코드와 같이 문자열이 저장된 변수를 바로 비교하게 되면 그 변수가 저장되어 있는 주소가 다르기 때문에 다르다는 결과가 나온다.
  * 정확한 비교를 위해서는 실제 문자열이 저장되어 있는 곳으로 이동하여, 각 문자를 하나씩 비교해야 된다. 
#### 생각해보기
* 💁‍♂ : 문자열을 비교하는 코드는 어떻게 작성해야 할까요?
  * 🙋‍♀️ : strcmp 함수를 이용하여 비교합니다.  
    int strcmp(const char *str1, const char *str2)

### 5️⃣ 문자열 복사
#### 강의 요약
``` C
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```
* 두 문자열을 실제로 메모리상에서 복사하려면 위 코드와 같이 메모리 할당 함수를 사용해야 한다.
  * 아래는 위 코드의 흐름이다. 
    1. malloc이라는 함수를 이용해 t를 정의한다.
       * malloc이라는 함수를 정해진 크기만큼 메모리를 할당하는 함수이다.
       * s 문자열의 길이에 널 종단 문자(\0)에 해당하는 1을 더한 만큼 메모리를 할당한다.
    2. 루프를 돌면서 s 문자열에 있는 문자 하나 하나를 t 배열에 복사해준다.
    3. 위 코드를 실행시켜 입력값으로 "emma"를 주면 s는 "emma", t는 "Emma"가 출력된다.
#### 생각해보기
* 💁‍♂ : 배운 바와 같이 메모리 할당을 통해 문자열을 복사하지 않고, 단순히 문자열의 주소만 복사했을 때는 어떤 문제가 생길까요?
  * 🙋‍♀️ : 단순히 문자열 주소만 복사했을 경우, 복사한 문자열을 변경 삭제 등 가공작업을 할 때 결국 원본을 가르키는 것이기 때문에 원본 손상이 있을 수 있습니다.  
    따라서 원본을 유지하고 복사본으로 문자열을 가공하고자 할 때는 메모리 할당을 통해 문자열을 복사해야 합니다.

### 6️⃣ 메모리 할당과 해제
#### 강의 요약
* malloc 함수를 이요하여 메모리를 할당한 후에는 free 함수를 이용해 메모리를 해제해줘야 한다.
  * 그렇지 않은 경우, 메모리에 저장한 값은 쓰레기 값으로 남게 되어 메모리 용량의 낭비가 발생하기 떄문이다. 
    * 이러한 현상을 '메모리 누수'라고 일컫는다.
``` C
#include <stdlib.h>

void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;
}

int main(void)
{
    f();
    return 0;
}
```
* 위 코드를 살펴보자.
  * f 함수를 보면 먼저 포인터 x에는 int의 사이즈(4바이트)에 10배에 해당하는 크기의 메모리, 즉 40바이트를 할당한다.
    * 그리고 x의 10번째 값으로 0을 할당한다.
  * main 함수에서 f를 실행하게 되는데, 이 코드는 버퍼 오버플로우와 메모리 누수 두가지 문제점이 있다.
    * 버퍼 오버플로우는 `x[10] = 0;`로 인해 발생한다.
      * 사이즈 10의 int형 배열을 만들었는데, 배열의 인덱스 10은 11번째 인덱스에 접근하므로 이는 정의되지 않은 것이기 때문에 버퍼 오버플로우가 발생한다.
      * 이는 0에서 9사이의  인덱스를 사용하면 해결할 수 있다.
    * 메모리 누수는 x라는 포인터를 통해 할당한 메모리를 해제하지 않았기 때문에 발생한다.
      * `free(x);`라는 코드를 추가해줌으로써 해결할 수 있다.
#### 생각해보기
* 💁‍♂ : 제한된 메모리를 가지고 프로그래밍을 할 때 메모리를 해제하지 않으면 어떤 문제가 발생할 수 있을까요?
  * 🙋‍♀️ : 힙 메모리에서 누수가 발생하여 메모리 낭비가 되어 성능이 저하됩니다.  
    프로그램이 끝나면 자동으로 메모리를 해제 기능을 지원하는 OS들이 있지만 그렇지 않은 OS에 대응하기 위해서는 메모리 해제가 습관 되어야 합니다.

## [💡 퀴즈](https://www.boostcourse.org/cs112/joinLectures/41497)

## 🎞 회고
