# 🚀 4주차 - 알고리즘

## [👨‍🏫 강의](https://www.boostcourse.org/cs112/joinLectures/41488)
### 1️⃣ 검색 알고리즘
#### 강의 요약
* 배열은 한 자료형의 여러 값들이 메모리상에 모여있는 구조이다.
  * 컴퓨터는 이 값들에 접근할 때 배열의 인덱스 하나하나를 접근한다.
  * 어떤 값이 배열 안에 속해 있는지 찾아 보기 위해서는 배열이 정렬되어 있는지 여부에 따라 선형 검색과 이진검색 방법을 사용할 수 있다.
* 선형 검색
  * 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사한다.
    ```
    For i from 0 to n–1

        If i'th element is 50

            Return true

    Return false
    ```
* 이진 검색
  * 배열이 정렬되어 있을 때 사용하는 방법이다.
  * 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은(작은 값이 저장되어 있는) 인덱스 또는 큰(큰 값이 저장되어 있는) 인덱스로 이동을 반복하며 검사한다.
    ```
    If no items

        Return false

    If middle item is 50

        Return true

    Else if 50 < middle item

        Search left half

    Else if 50 > middle item

        Search right half
    ```
#### 생각해보기
* 💁‍♂ : 만약 정렬되지 않은 배열이 있다면, 선형 검색이 빠를까요 이진 검색이 빠를까요?
  * 🙋‍♀️ : 어느 검색이 빠르다고 말할 수 없습니다. 정렬되어 있지 않다면 찾는 값이 어느쪽에 있는지 알 수 없기 때문입니다.  
    또한 정렬되지 않은 배열에서 이진 검색을 한다면 크거나 작은 값을 기준으로 검색을 하는 것이 아니라 그저 인덱스의 번호를 기준으로 검색을 해야하며, 한쪽에서 검색이 안 된다면 다른 한쪽으로 또 검색을 해야하는 처리를 해야합니다. 때문에 저라면 정렬되지 않은 배열에서는 선형검색을 택할 것 같습니다.
  
### 2️⃣ 알고리즘 표기법
#### 강의 요약
* Big O
  * 알고리즘 실행 시간의 상한을 나타낸 것
  * O는 "on the order of"의 약자로, 쉽게 생각하면 "~만큼의 정도로 커지는"것이라고 볼 수 있다.
  * O(n)은 n만큼 커지는 것이므로 n이 늘어날수록 선형적으로 증가하게 된다.
    * O(n/2)도 결국 n이 매우 커지면 1/2은 큰 의미가 없어지므로 O(n)이라고 볼 수 있다.
  * 주로 아래 목록과 같은 Big O 표기가 사용된다.
    * O(n^2)
    * O(n log n)
    * O(n) `예) 선형 검색`
    * O(log n) `예) 이진 검색`
    * O(1)
* Big Ω
  * 알고리즘 실행 시간의 하한을 나타낸 것
  * 예를 들어 선형 검색에서는 n개의 항목이 있을 때 최대 n번의 검색을 해야하므로 상한이 O(n)이 되지만 운이 좋다면 한 번만에 검색을 끝낼 수도 있으므로 하한은 Ω(1)이 된다.
  * 주로 아래 목록과 같은 Big Ω 표기가 사용된다.
    * Ω(n^2)
    * Ω(n log n)
    * Ω(n) `예) 배열 안에 존재하는 값의 개수 세기`
    * Ω(log n)
    * Ω(1) `예) 선형 검색, 이진 검색`
#### 생각해보기
* 💁‍♂ : 실행시간의 상한이 낮은 알고리즘이 더 좋을까요, 하한이 낮은 알고리즘이 더 좋을까요?
  * 🙋‍♀️ : 입력값, 주어지는 값이 비슷해서 그에 따라 하한이 낮은 알고리즘의 하한값에 부합하는 프로그램이라면 하한이 낮은 알고리즘이 더 좋은 성능을 보일 것 입니다.  
    하지만 입력값, 주어지는 값이 만약 달라졌을 경우 유지보수에 비용을 쏟아야 하므로 항상 입력값, 주어지는 값이 비슷한 프로그램이 아니라면 실행시간의 상한이 낮은 알고리즘으로 구현해야 장기적으로 좋다고 생각합니다.   
    또한 최악의 상황을 항상 고려해야 하는 프로그램에서는 항상 상한이 낮은 알고리즘을 선택해야 합니다.

### 3️⃣ 선형 검색
#### 강의 요약
* 선형 검색
  * 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색하는 방법
* 효율성 그리고 비효율성
  * 선형 검색 알고리즘은 정확하지만 아주 효율적이지 못한 방법이다.
    * 리스트의 길이가 n이라고 했을 때, 최악의 경우 리스트의 모든 원소를 확인해야 하므로 n만큼 실행된다.
      * 여기서 최악의 상황은 찾고자 하는 자료가 맨 마지막에 있거나 리스트 안에 없는 경우를 말한다.
      * 반대로 최선의 상황은 처음 시도했을 때 찾고자 하는 값이 있는 경우이다.
    * 평균적으로 선형 검색이 최악의 상황에서 종료되는 것에 가깝다고 가정할 수 있다.
  * 선형 검색은 자료가 정렬되어 있지 않거나 그 어떤 정보도 없어 하나씩 찾아야 하는 경우에 유용하다.
    * 이런 경우는 무작위로 탐색하는 것보다 순서대로 탐색하는 것이 더 효율적이다.
* 정렬은 시간이 오래 걸리고 공간을 더 차지하지만, 정렬 과정을 진행하면 여러 번 리스트를 검색해야 하거나 매우 큰 리스트를 검색해야 할 경우 시간을 단축할 수 있다.
* 구조체
  * 새로운 자료형으로 구조체를 정의할 수 있다.
  * 구조체 안에 포함된 속성값은 '.'으로 연결해서 접근할 수 있다.
    ``` C
    typedef struct
    {
        string name; // 이름
        string number; // 전화번호
    }
    person;
    ```
    * 위와 같이 person이라는 이름의 구조체를 자료형으로 정의하고 person 자료형의 배열을 선언할 수 있다.
    * `person a;` 라는 변수가 있다면 a.name또는 a.number이 각각 이름과 전화번호를 저장하는 변수가 된다.
  * 구조체를 사용하면 더 확장성 있는 프로그램을 만들 수 있다.
#### 생각해보기
* 💁‍♂ : 전화번호부와 같이 구조체를 정의하여 관리 및 검색을 하면 더 편리한 예는 또 무엇이 있을까요?
  * 🙋‍♀️ : 현실의 정보를 담고 있는 대부분 정보들에는 오직 하나의 정보를 담고 있는 경우가 드물기 때문에 거의 모든 경우에 사용할 수 있습니다.  
    가령 3주차 배열 표현의 예를 들었던 시험의 답안 목록 같은 경우도 구조체로 나타낸다면 학생, 시험과목, 답안 배열 등의 자료형들로 구조체를 정의할 수 있고 CS50의 팀별 인원 수 같은 경우도 기수, 코치, 리드부스터, 스터들 배열, 인원 수등의 자료형들로 구조체를 정의할 수 있습니다.  
    위와 같이 구조체로 정의한다면 한 과목의 시험 답안을 아는 프로그램과 인원 수 검색만 할 수 있는 프로그램에서 그치지 않고 여러 정보들을 알 수 있는 프로그램으로 확장성이 높아질 수 있습니다.
#### 배운점
> 와우 구조체 너무 오랜만이었다. 객체지향의 class에 익숙해있던 나에게 구조체의 존재를 다시 인식시켜준 건 아주 반가운 소식이었다.  
> 구조체처럼 잊고 있던 정보들이 다시 들어오니까 C도 다시 점점 재밌어진다!!

## [💡 퀴즈](https://www.boostcourse.org/cs112/joinLectures/41496)
## 🎞 회고
